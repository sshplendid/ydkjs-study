# 5. 프로그램 성능

- 비동기성이 중요했던 이유는? 바로 성능때문
- 해당 장에서는 로컬 영역의 비동기 패턴보다 넓은 시야에서 프로그램 수준의 성능을 고찰한다.

## 5.1 웹 워커
 - js는 싱글쓰레드로 동작하나, 브라우저는 그렇지 않는다.
 - web worker 는 브라우저의 main thread와 별개로 돌아가는 쓰레드를 생성하여 작업 병행성을 추구함
 - 예제
일단 Web Worker 가 실행할 수 있는 별도의 Javascript 파일이 필요하다
```jsx
// worker.js
var n = 'done';
// 오래걸리는
// 무언가를
// 처리함...
postMessage(n);
```
그리고, 이를 생성할 Javascript 가 필요하다.
```jsx
<body><!-- some --></body>
<script>
    if( window.Worker ) {
        var worker = new Worker('worker.js');
        worker.onmessage = (event) => {
            console.log(event.data);
            // 'done'
            worker.terminate();
        };
    }
</script>
```
과정설명
1. main thread 에서 new Worker('worker.js') 로 worker thread 를 만든다.
2. main thread 에서 worker.onmessage 에 worker 의 메시지를 전달받기위한 이벤트 핸들러를 등록한다.
3. worker thread 에서 worker.js 의 작업 처리후 postMessage() 로 데이터를 main thread 의 worker.onmessage 에게 전달한다.
4. 만약 더이상 worker thread 가 필요 없거나, 작업을 종료해야 한다면, worker.terminate() 를 호출한다.

### 5.1.1 워커 환경
 - 워커 내부에서는 메인 프로그램의 자원에 접근할 수 없다.
 - 다만 워커는 네트워크 작업, 타이머 설정이 가능하며 navigator, location, JSON, applicationCache 등 중요 전역 변수/특성을 자게 복사하여 접근할 수 있다.
 - 웹 워커의 주요 용도는 아래와 같다.
  - 처리 집약적 수학 계싼
  - 대용량 데이터 세트 정렬
  - 데이터 작업(압축,오디오 분석, 이미지 픽셀 변환 등)
  - 트래픽 높은 네트워크 통신

### 5.1.2 데이터 전송
 - 과거 데이터 전송 : 직렬화(속도가 떨어지고 데이터 복사 과정에서 메모리 사용량이 늘어나는 단점)
 - 구조화된 복제 알고리즘으로 객체를 복사/복제(IE 10+ 및 주요 브라우저가 지원. 트랜스퍼러블 객체를 지원하지 않는 브라우저에서 사용)
 - 트랜스퍼러블 객체 : 데이터 자체는 그대로 두고 객체의 소유권만 전송하는 방식(Uint8Array와 같은 타입화 배열이 그 예)
 ```jsx
 // 예를 들어 foo는 Uint8Array 타입이다.
 postMessage(foo.buffer, [foo.buffer]);  // 첫번째 인자는 원시버퍼, 두번째 인자는 전송 대상 목록 
 ```
 
### 5.1.3 공유 워커
 - 하나의 워커가 여러개 문서에 응답하는 형태. 
 - 같은 페이지(공통기능)에 탭을 여러 개 읽어들이는 웹사이트/앱에서는 전용 워커가 중복되는 걸 방지하여 시스템 자원 점유율을 낮충야 하기에, 해당 페이지 인스터늣가 서로 공유할 수 있는 하나의 중앙 워커를 둔다.
 - 공유 워커는 다수의 프로그램 인스턴스/페이지와 연결 가능한 관계로 메세지 출처가 어느 프로그램인지 파악할 방법이 필요하다. 그래서 port라는 고유 식별자가 있고, 이를 통해 호출프로그램과 워커가 통신한다.
 - 공유 워커에서는 "connect"라는 이벤트를 처리해야하는데, 이부분만 차이가 있을뿐 공유 워커와 전용 워커의 기능과 의도는 같다고 한다.
 ```jsx
 //공유 워커 내부에서
 addEventListener("connect", function(evt) {
  //이 접속에 할당된 포트
  var port = evt.ports[0];
  port.addEventListener("message", function(evt){ 
    //...
    port.postMessage(..);
    //...
  });
  //포트 접속 초기화
  port.start();
 });
 ```
 
### 5.1.4 웹 워커 폴리필
- 자바스크립트 프로그램의 병렬 실행 시 웹 워커의 성능은 상당히 매력적이지만, 비호환 구형 브라우저도 있는 경우도 감안해야 한다.
- 워커는 API고 구문은 아니라서 폴리필이 가능하다.(저자가 직접 폴리필을 작성 -> https://gist.github.com/getify/1b26accb1a09aa53ad25)
- 워커를 지원하지 않는 브라우저는 성능상 멀티쓰레딩을 흉내조차 낼 수 없다.

## 5.2 SIMD(단일명령, 다중 데이터 : Single Instruction, Multiple Data)
- SIMD는 데이터 병행성을 나타내는 형식으로, 웹워커의 작업 병행성과는 대비되는 개념이다.
- 프로그램 로직덩이를 병렬 실행하는 것이 아닌, 데이터 비트를 병렬로 처리하는 일이다.
- 저자는 SIMD가 ES7에 포함될 것이라고 생각했고, SIMD.js는 저수준 데이터의 병렬 처리를 위한 명세로 제안됐다. 
- 하지만 WebAssembly를 위한 SIMD 제안이 진행되면서 SIMD.js 제안은 Stage 3(Candidate 단계)에서 제거됐다. 라고 한다.(https://d2.naver.com/helloworld/7495331)

## 5.3 asm.js
 - asm.js는 자바스크립트 언어에서 고도로 최적화 가능한 부분 집합을 말한다. 매우 공격적으로 저수준 최적화를 하는 등의 특별한 조치를 한다.
 - 위키에서는 C/C++코드를 웹으로 포팅하는데 유용하다고 한다.(그러나 현재 WebAssembly를 더 많이 사용한다고 한다.)
 
### 5.3.1 asm.js 최적화
 - 자바스크립트가 상이한 타입의 변수 값들을 추적하면서 필요시 강제변환을 처리하는데, 이떄 최적화를 방해하는 요소가 많기에 해당 추적 단계를 건너뛰도록 하는 수법을 사용한다.
 - 예를들면 아래 코드를 아래아래 코드로 바꾸어서 값 자체는 영향이 없지만, 32비트 정수 타입이 되도록 강제하려고 0을 | 연산 하여 강제변환 추적을 건너뛴다.
 ```jsx
 var a = 42;
 //...
 var b = a;
 ```
 ```jsx
 var a = 42;
 // ...
 var b = a | 0;
 ```
 
### 5.3.2 asm.js 모듈
 - 메모리할당, 가비지콜렉션, 스코프 접근은 늘 자바스크립트 성능 문제의 논란거리였는데, 그 해결방안으로 asm.js에서 더 정형화한 asm.js모듈을 선언한다.
 - asm.js모듈은 단순 렉시컬 스코프를 통해 전역 객체를 쓰는 대신 필요한 심볼을 가져오기 위해 엄격하게 규정된 네임스페이스를 분명히 전달한다.
 - 또, 힙을 반드시 선언하고 전달해서 asm.js모듈이 메모리 천(휘젓기) 을 일으키지 않고 사전 예약된 공간을 사용핟록 해야 한다.
 힙은 아래와 같이 할당하고
 ```jsx
 var heap = new ArrayBuffer(0x10000); //64k 힙
 ```
 아래와 같이 heap 버퍼에 값을 담도록 사용한다.
 ```jsx
 var arr = new Float64Array(heap);
 ```
 - asm.js코드에 최적화 능력을 부여하는 제약의 본질상 그 사용 영역 또한 한정되는것은 어쩔 수 없다. 모든 자바스크립트의 최적화 도구라기보다는 게임그래픽 처리 특유의 수학 연산 집약적인 특수작업에 최적화된 도구이다.
 
