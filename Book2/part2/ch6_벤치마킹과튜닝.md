# CH6. 벤치마킹과 튜닝
- 해당 장에서는 ++a를 a++보다 빨리 실행하는 미시적인 성능 튜닝에 집착하지 않는다.
- 다만 자바스크립트 성능에 있어서 중요한 부분과 그렇지 않은 부분을 가려내고 차이점이 무엇인지 밝힌느 일에 초점을 두고자 한다.

## 6.1 벤치마킹
- 사실 아래와 같은 식의 벤치마킹 방법은 많이들 쓰지만 틀린 방법이다.
- 자바스크립트 성능 벤치마킹은 주어진 작업 실행 시간 동안 측정한 결과를 보고 무엇을 알수 있는지 없는지부터 파악하는게 기본이라 한다.
- 매번 엔진/시스템이 그때그때 어떤 식으로 간섭을 일으킬지 예측할 수 없고 더빠른 경우도 있는 등 예측 불허이기 때문이다.
```jsx
var start = (new Date()).getTime(); // 또는 'Date.now()'
//작업수행
var end = (new Date()).getTime();
console.log("소요 시간 : ", (end-start));
```

### 6.1.1 반복
- 6.1 의 예제 코드를 반복해서 평균내면 어떨까? 라는 물음에 대한답은?
답 : 단순 평균치만으로는 특이점이 조금만 있어도 결과가 왜곡된다. 왜곡을 상쇄하려면 샘플이 아주 많아야 하고, 최고/최악 격차도 파악해야 하며, 자료의 신뢰성을 위한 정량적 데이터도 필요하다.

### 6.1.2 Benchmark.js
- John-David dalton 과 Mathias Bynens 와 같은 사람들이 통계학적으로 검증된 벤치마킹 도구를 내놓았는데 이걸 사용하길 권장한다.
- http://benchmarkjs.com/docs 에 API문서가 잘 정리되어 있고, 구현 상세와 방법론도 책에 주석으로 정리되어 있으니 읽기를 권장한다.
- 선은 벤치마킹에 필요한 제반 설정의 복잡함을 대신 처리해주고, 작업 X와 작업 Y중 어느 쪽이 더 빠른지 판단해 준다.
- Benchmark.js 는 브라우저 환경의 자바스크립트 테스팅에 주로 쓰지만 브라우저 이외의 환경(node.js 등)에서도 사용할 수 있다.

## 6.2 콘텍스트가 제일
- X, Y 작업 간 성능 비교를 할떄 콘텍스트를 살펴야 한다. X가 Y보다 빠른것 처럼 나왔다고 해도 X가 Y보다 빠르다고 결론 내릴 수는 없는 것이다.

### 6.2.1 엔진 최적화
- 6.2에서 언급했듯이 X가 Y보다 빠르다고 단정지을 수는 없다. 예를들어 아래와 같은 미세 성능 테스트를 할때도 적용된다.
```jsx
var twelve = "12";
var foo = "foo";

//test1
var X1 = parseInt(twelve);
var X2 = parseInt(foo);

//test2
var Y1 = Number(twelve);
var Y2 = Number(foo);
```
1. parseInt()인자가 Number()와는 다르게 첫번째 문자인 f 나 1에서 멈추므로 성능에 영향이 있을것이다 라는 가설에는 확신이 없다.
2. 엔진이 해당 값을 한군데에서만 사용하면 그냥 Number("12") 를 12로 대체하고 parseInt()에도 같거나 다른 결론을 내릴 수 있기 때문이다.
3. 결국 상황에 따라서 엔진이 최적화를 결정할지 안할지가 결정되기 때문에 프로그램의 복잡도가 높아짐에 따라서 더욱 더 성능을 비교하기는 어려울 것이다.

- 결론 : 자바스크립트의 깊숙한 곳에서 무슨 일이 벌어질지 도저히 알 수 없고 추측/추정만 무성할 뿐 확실한 결정을 내릴만한 구체적인 증거는 없다.
- 그렇다고 유용한 테스팅이 불가능하다는 것은 아니다. 가장 실제와 유사한 의미있는 코드를 테스트 해야 본질에 가까운 결과를 얻게 될 가능성이 높음을 인지해야 한다.

## 6.3 jsPerf.com
- Benchmark.js 는 js 실행환경에 구애받지 않고 코드 성능을 테스트할 수 있는 유용한 도구지만, 신뢰할만한 결론을 원한다면 다양한 환경(desktop browser, mobile device etc)에서 테스트한 결과를 취합해야 한다.
- 크롬에서 실행하니 X가 Y보다 빠르다고 해서 다른 브라우저도 그럴 것이라 넘겨짚지는 말자. 실 사용자를 대상으로 멀티 브라우저 테스트한 결과를 상호 참조 해야 할 수도 있다.
- jsPerf가 위와 같은 목적으로 개발된 웹 사이트로 접속 가능한 공개 URL에 대해 Benchmark.js라이브러리를 이용해 통계적으로 믿음직한 테스트를 대행한다.
- 테스트할때마다 결과를 수집,저장하고 다른 사람도 볼 수 있또록 한 페이지에 누적 결과를 그래프로 보여준다.(라고는 하지만 난 왜 jsPerf.com에 접속이 안되는지 모르겠다...)

### 6.3.1 정상 테스트
- jsPerf는 멋진 도구지만 결함이 있는 tc들의 예
```jsx
//case1
var x = [];
for(var i=0; i<10; i++) {
  x[i] = "x";
}

//case2
var x = [];
for(var i=0; i<10; i++) {
  x[x.length] = "x";
}

//case3
var x =[];
for(var i=0; i<10; i++) {
  x.push("x");
}
```
1. Benchmark.js가 필요시 반복을 대신하기 때문에 for 루프는 쓸데없는 잡음으로 남을 가능성이 높다.
2. tc마다 x를 선언/초기화 했는데 불필요한 코드다. 설정코드에 x=[] 하면 tc가 아닌 테스트사이클 시작부에서 한번만 실행됫을것인데, for루프에서 의도한 크기 10을 넘어 x가 계속 불어날 것이다.
3. 아마도 이 테스트는 x.length, x.push() 가 배열 x에 원소를 추가할 때 성능에 얼마나 영향을 끼치는지 알아내는게 목적인거 같다. push()는 함수 호출이므로 당연히 [] 접근보다 느리기에 아마 tc1,2가 3보다는 빠를 것이다.

- 사과냐 오렌지냐 오류의 예
```jsx
//case 1
var x = ["민준",서연","지후","민서","현우"];
x.sort();

//case2
var x = ["민준",서연","지후","민서","현우"];
x.sort( function mySort(a,b){
  if(a < b) return -1;
  if(a > b) reutrn 1;
  return 0;
});
```
- mySort()라는 custom comparator와 기본 내장 비교기 성능 비교문인데, mySort()가 인라인 함수 표현식인 탓에 case2는 커스톰 js함수뿐 아니라 테스트 반복 시 새 함수 표현식도 함꼐 테스트하여 더 느리다.(2~20%)
- 인라인 함수 표현식의 성능비교의도가 아니었다면, mySort() 선언부를 페이지 설정부에 넣고 테스트 케이스에서 x.sort(mySort)로 명칭에 의한 참조를 하는 편이 개선된 식이다.

- 결과가 다른 tc를 비교하려고 하는것도 무용지물인 테스트이다. (p.386)

- 불리언 값이 아닌 표현식x를 삼항연산자로 강제변환시 성능에 미치는 영향을 알아보는 테스트의 예
- 아래 예도 문제가 있다. case1은 값을 세팅하지만, case2는 세팅하지 않으므로 왜곡이 있다고 한다.
```jsx
//case1
var x = false;
var y = x ? 1 : 2;

//case2
var x;
var y = x ? 1 : 2;
```
그래서 아래와 같이 바꾸어 테스트 하는 것이 좀 더 정확한 테스트가 될 것이다.
```jsx
//case1
var x = false;
var y = x ? 1 : 2;

//case2
var x = undefined;
var y = x ? 1 : 2;
```

## 6.4 좋은 테스트를 작성하려면
- 좋은 테스트를 작성하고 싶다면? 
1. TC사이에 차이점은 무엇이고, 그 차이가 의도적인지 비의도적인지를 철저하게 분석하고 고민해야 한다.
2. 비의도적인 차이는 쉽게 발생하고 테스트 결과를 왜곡하기 때문에, 더 명확한 테스트를 작성해야 하고 미묘한 세부분까지 문서화해야 한다.
3. 테스트와 상관없는 부분은 페이지나 테스트 설정부에 미리 선언하는 형태로 따로 빼놓는다.
4. 사소한 코드 조각에 집착하지 말고 넓은 연관된 범위의 콘텍스트로 포괄하면 더 나은 벤치마크/테스트를 할 수 있다.

## 6.5 미시성능
- 성능 벤치마킹 할때는 자신이 작성한 코드와 실제 엔진이 실행하는 코드가 같지 않을 수 있다는 사실을 당연하게 받아들여야 한다. 

예를들면 아래 코드는 컴파일러가 foo가 한곳밖에 사용되지 않는걸 안다면 아래아래 코드 처럼 상수로 대치하게 된다.
```jsx
var foo = 41;
(function(){
  (function(){
    (function(baz){
      var bar = foo + baz;
       // ...
     })(1);
   })();
 })();
```
```jsx
(function(){
  (function(){
    (function(baz){
      var bar = 41 + baz;
       // ...
     })(1);
   })();
 })();
```

- factiroal도 마찬가지로 c언어로 코딩하여 고급 최적화 옵션을 주고 컴파일하면 컴파일러는 factorial(5)를 상수 120으로 대체하고 함수 정의부와 호출 코드를 날려버린다.
- factorial하니까 n*factorial(n-1)과 n*=factorial(--n) 중 어느 쪽이 빠를지 궁금하지만 엔진이 컨텍스트에 따라 다르게 실행할 가능성(풀림 재귀) 이 있다.
- --n대 n--문제는 n--가 이론적으로 어셈블리 작업량이 적어 최적화에 유리하다고 알려져 있지만, 이런 식의 강박증은 현대 자바스크립트에서는 헛소리로 치부된다고 한다.
- 성능 미시 최적화보다는 코드의 가독성에 힘을 쓰는게 더 낫다. 최적화에 있어서 인간이 자바스크립트 엔진을 능가할 수 있다는 생각은 버리는 것이 좋다.

### 6.5.1 똑같은 엔진은 없다.
 - 상이한 브라우저에 탑재된 각 자바스크립트 엔진은 모두 '스펙은 준수'하지만 코드 처리방식은 제각각이다.
 - v8 자바스크립트 엔진의 내부 구현 로직을 분석하고 작동 원리를 활용할 수 있는 방향으로 코딩하는 문제가 연구되었는데 거기서 언급된 몇몇 사례가 있다.
 1. 함수 간에 arguments 변수를 전달하지 말라. 누수 탓에 함수 구현체가 느려진다.
 2. try catch 구문은 함수에서 뗴어내라. 브라우저는 try catch 구문이 포함된 함수를 최적화하려고 전력 질주하므로 이 구문을 함수에 남겨두면 주변 코드는 최적화하고 반최적화를 하여 불이익을 받을 소지가 있다.
 - 하지만 팁에 집착하지 말고, 일반적인 관점에서 v8 전용 최적화 방식을 정상 테스트 해보자고 한다 : 지금 짜놓은 코드가 수년 후 버전에서도 최적화가 된 코드라고 자부할 수 없기 때문이다.
 예) 예전에는 문자열 원소값을 붙일때 +로 추가하는것 보다 join("") 을 쓰는게 더 빠르다고 구전되어 왔으나, 어느 시점부터 자바스크립트 엔진은 +로 문자열을 붙이는 부분을 최적화하여, join()을 애용한 코드는 비최적화가 된 것이다.
 - 그렇다고 특정 브라우저에서 불거진 성능문제 때문에 다른 브라우저에서 비최적 접근 방식을 사용하라고 권장하는 것은 무리가 있다. 개발자는 올바른 코드를 작성하고 나중에 브라우저 업데이트를 기다리는 편이 낫다.
 
 ### 6.5.2 큰 그림
  - 거듭 말하지만 미묘한 미세성능에 사로잡히지 말고 최적화의 큰 그림을 볼 수 있어야 한다.
  - 임계 경로에서 실행되는 코드인지 먼저 확인하라. 임계 경로에 있찌 않은 코드면 최적화해도 별 효과가 없을 가능성이 높다.
  - 아래 5개 옵션중 어느 것이 가장 빠를지 생각해보자 
  : 일단 parseInt()가 가장 느리다. 다만 x가 "42px"같은 css스타일이면 좋은 옵션이다. Number()도 함수 호출이기에 다음으로 느리다. 물론 엔진이 +x처럼 인라인 처리 할 수 도 있다.
    그러나 +x대 x|0 성능 비교는 미세성능 이슈니 이를 비교하는 것은 시간 낭비라고 한다. 성능이 얼추 비슷한 옵션하에서는 가독성을 관심사로 다루어야 한다.
  ```jsx
  var x = "42";
  var y = x/2; //option1 : 자동으로 암시적 강제변환이 일어나게 한다.
  var y = parseInt(x, 0)/2; // option2 : parseInt()를 쓴다.
  var y = Number(x)/2; // option3 : Number()를 쓴다.
  var y = +x /2 ; // option4 : '+'단항 연산자를 쓴다.
  var y = (x | 0) /2; // option5 : '|' 단항 연산자를 쓴다.
```

## 6.6 꼬리 호출 최적화(TCO)
- ES6에서 보장하는 기능으로 꼬리 호출은 함수 호출부가 다른 함수의 꼬리 부분에 있고 호출이 끝나면 더 이상 수행할 작업을 남기지 않고 최적화(스택 프레임을 재사용)하는 방식이다.
예제
```jsx
function foo(x) {
  return x;
}
function bar(y) {
  return foo(y+1); //꼬리 호출
}
function baz() {
  return 1 + bar(40); //꼬리 호출 아님
}
baz(); //42
```
- 새 함수를 호출하려면 스택 프레임이라는 호출 스택을 쌓기 위해 별도의 메모리 할당이 필요하나, TCO능력을 갖춘 엔진은 예제의 foo(y+1)처럼 꼬리위치에서 호출된다는 사실을 알면 기본적으로 bar()가 끝난 뒤 foo()를 부를때 기존 bar()가 쓰던걸 쓴다.
- 이는 속도도 빠르지만 메모리도 덜 쓰는 일석이조의 효과가 있고, 특히나 재귀 호출에서 현저한 효과를 기대할 수 있다.
재귀 꼬리 호출 팩토리얼 예제
```jsx
function factorial(n) {
  function fact(n, res) {
    if (n<2) return res;
    return fact(n-1, n*res);
  }
  return fact(n,1);
}
factorial(5); //120
```
