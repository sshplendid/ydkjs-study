# 4. 클래스와 객체의 혼합

클래스 지향 개념은 자바스크립트 객체 체계와 태생부터 잘 맞지 않았음

개발자들은 이 한계를 극복하고자 노력해옴

## 4.1. 클래스 이론

- 클래스와 상속은 **실생활 영역의 문제**를 소프트웨어로 모델링하기 위한 방법
- 객체 지향/클래스 지향 프로그래밍에서의 데이터
    - **데이터**와 **동작**을 잘 감싸는 것이 올바른 설계 (캡슐화)
- 클래스는 특정 자료구조를 **분류**하는 용도로 사용
    - 차(Car)는 탈것(vehicle)이다 (`is-a` 관계, car is a vehicle)
    - 탈것의 특성: 이동한다(move), 탈수있다(get on), ...
    - 차의 특성: 바퀴가 4개, 엔진, ...
- 각각 Vehicle, Car 클래스로 모델링
- 만약 자전거라는 타입을 만들어야 한다면? 그때 이동한다 라는 동작을 다시 정의할 것인가?
    - 상속을 통해서 코드 재사용이 가능
- 다형성: 부모 클래스의 동작을 구체화해서 재정의(override) 하는 것
    - Car::move → 바퀴 4개로 움직인다
    - Bike::move → 바퀴 2개로 움직인다
    - → 움직인다는 동작은 같지만 구체적으로 어떻게 행동할지는 클래스마다 다름
    - 하지만 자바스크립트에선 불안정한 코드가 만들어진다(후술)

```jsx
class Vehicle {
	move (destination): {
		console.log(`${destsination}으로 이동한다.`)
	}
	getOn (driver): {
		console.log(`${driver}가 탔다.`)
	}
}

class Car extends Vehicle {
	constructor(wheels, engine);
}
```

### 4.1.1. 클래스 디자인 패턴

> 디자인 패턴이란 소프트웨어 디자인 패턴은 소프트웨어 공학에서 소프트웨어 디자인에서 특정 문맥에서 공통적으로 발생하는 문제에 대해 재사용 가능한 해결책이다.

- 클래스도 디자인 패턴인가?
- 클래스를 꼭 써야하는가?
    - Java는 모든게 클래스
    - 함수형 언어에선?
    - C/C++에선 선택 가능

### 4.1.2. 자바스크립트 클래스

- ES6 부터 class 키워드 사용 가능
- 그렇다면 JS는 클래스가 있는가? →  NO
- 클래스 디자인 패턴을 실현하려 **노력해옴**
- 클래스처럼 보이지만 사실은 억지로 고친 것에 불과 (Syntatic sugar)
- 자바스크립트에서 클래스 문법을 사용할지는 개발자의 선택

## 4.2. 클래스 체계

- Stack의 예
    - push, pop 등의 동작
    - 접근할 수 없는 변수 (상태)
    - 데이터 추가/수정은 외부에서 접근할 수 있는 동작(push, pop, ...)등으로 해결
    - Stack 클래스를 인스턴스화해야 작업을 수행할 자료 구조가 생성

### 4.2.1. 건축

- 클래스와 인스턴스: 설계도와 실제 건물의 관계? 빵틀과 붕어빵?

### 4.2.2. 생성자

- 인스턴스는 생성자라는 특별한 메서드로 생성한다
- 생성자의 역할은 인스턴스의 필요정보를 초기화하는 역할
- 보통 `new` 키워드를 사용해서 생성자를 호출

## 4.3. 클래스 상속

- 클래스의 형질을 자식 클래스에게 물려줄 수 있음 (상태, 동작)
- 하지만 부모의 형질을 재정의할 수 있음 (override)

```jsx
class Vehicle {
	engines = 1
	iginition() {
		output('엔진을 켠다')
	}
	drive() {
		ignition()
		output('앞으로 간다')
	}
}

class Car extends Vehicle {
	wheels = 4
	drive() { // override
		super.drive()
		output(wheel, '개의 바퀴로 앞으로 간다')
	}
}

class Boat extends Vehicle {
	engines = 2
	iginition() { // override
		output(engines, '개의 엔진을 켠다')
	}
	pilot() { // Boat만 가지고 있는 동작
		super.drive()
		output('항해한다.')
	}
}
```

### 4.3.1. 다형성

- 위 예제코드에서 `drive()` 메서드를 자체 메서드로 오버라이드 함
- 자식 클래스의 drive메서드는 super class의 drive 메서드를 호출 → 상대적 다형성
- 상대적 다형성 → '한 수준 더 상위로!' 레퍼런스를 거슬러 올라감
- Boat의 pilot 메서드를 호출할때 부모 ignition 메서드를 호출할까? → NO!

### 4.3.2. 다중 상속

- 다중 상속은 복잡도가 증가한다
- 마름모 문제: A, B 클래스가 C 클래스를 상속받고, D 클래스가 A, B 클래스를 상속받았을 때 어떤 클래스의 drive 메서드를 참조해야 할까?
- 다중 상속을 흉내내는 방법이 존재

## 4.4. 믹스인

- 자바스크립트는 **클래스**란 개념은 없고 오직 **객체**만 존재한다.
- 객체는 서로 연결된다.
- 믹스인은 다른 언어와 달리 클래스 복사 기능을 흉내낸다.

### 4.4.1. 명시적 믹스인

- 명시적으로 프로퍼티를 복사하는 유틸리티 함수를 작성
- 레퍼런스만 복사된다
- 이미 타겟에 있는 프로퍼티는 복사하지 않는다.

**다형성 재고**

- 명시적 의사다형성

```jsx
Vehicle.drive.call(this);
```

- 자바스크립트는 상대적 다형성을 제공하지 않음 (한단계 위로! 참고)
- 그래서 수퍼 클래스도 존재하는 메서드를 호출하려면 절대적 레퍼런스가 필요
- → 그래서 Vehicle.drive를 직접 호출
- 유지비용, 복잡도 증가 → 가능한 쓰지말자?

**사본 혼합**

- 먼저 믹스인을 한 뒤, 자식 클래스의 프로퍼티를 다시 믹스인한다. (덮어쓰기)
- 함수는 복사되지 않는다. 레퍼런스만 복사됨
- 원본 함수가 변경된다면 모든 레퍼런스를 가진 객체에 영향을 끼침
- 사용이 부담스러워진다면 사용 중단을 고려해야 한다.

**기생 상속**

- 명시적 믹스인 패턴의 변형 (더글러스 크록포드)
- 명시적/암시적 특징을 모두 가짐
- 수퍼 클래스의 객체를 생성한 뒤 자식 클래스의 형질을 수정

### 4.4.2. 암시적 믹스인

- 명시적 의사다형성과 밀접한 관계가 있음
- `cool` 메서드 호출로 `Another` 컨텍스에 바인딩 한다.
- 깔끔하고 관리하기 쉬운 코드 유지를 위해 **쓰지 않는편이 좋다** ?!?!

## 4.5. 정리하기

- 클래스는 디자인 패턴의 일종
- 자바스크립트는 유사하지만 다른 언어들과 클래스의 의미가 다르다. (흉내내기)
- 클래스는 복사를 의미한다.
- 자바스크립트는 객체 사본을 생성하지 않는다.
- 믹스인 패턴은 클래스 복사기능을 모방하기 위해 사용하지만 가독성이 떨어지고 유지보수가 어려워진다.
- 명시적 믹스인은 클래스 복사기능과 같지않다.
- 자바스크립트 클래스 모방은 당장 닥친 문제를 해결할 수 있어도 앞으로 터질 시한폭탄을 심어놓는 것과 다름없다.
