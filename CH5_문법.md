# 5. 문법

## 5.1. 문과 표현식

- 문장: 하나 이상의 어구로 구성된다.
- 표현식: 단일한, 특정한 결괏값으로 계산된다.

```jsx
var a = 3 * 6;
var b = a;
b;

a == 18 && console.log('a is 18'); // 이건 문장? 표현식?
```

### 5.1.1. 문의 완료값

- 모든 문장은 완료 값을 가진다.
- `var b = a`의 완료값은  → `undefined`
- 콘솔 창에서 `undefind`가 나오는 이유? → 문장의 완료값(결과)

- 블록은 내부의 가장 마지막 문/표현식의 완료값을 자신의 완료값으로 반환
- 아래와 같은 코드는 불가능

```jsx
var a, b;
a = if(true) {
	b = 4 + 2;
} // a === 6 ?
```

- do 표현식은 아직 [stage 1](https://github.com/tc39/proposal-do-expressions)
- `eval`을 사용하면 가능하다

하지만 굳이?

```jsx
var a, b;
a = do {
	if(true) {
		b = 2 + 4;
	}
};

a; // 6? 안됨
```

- `eval` 은 사용하지 말자 // 왜?

### 5.1.2. 표현식의 부수효과

- 대부분의 표현식에는 부수효과가 없지만, 아래 경우 부수효과가 발생한다.
    - 전역 변수를 참조하거나
    - 단항연산자(`++`, `--`)
    - `delete` → `boolean` 값을 리턴함
    - 할당(assign): 원체 부수효과
    - `let a = b = c = 42;` 는 b, c를 먼저 선언하지 않으면 전역변수를 만들게 된다

### 5.1.3. 컨텍스트

- 중괄호
    - 객체 리터럴
    - 레이블 // ? :  `continue`와 함께 레이블 점프가 가능함
    - JSON을 입력하면 에러가 난다? → 문법이 발전함에 따라 허용된건가?
        - `var a = {['age']: 1}` 이런 문법도 가능
    - 블록
    - 객체 분해

    ```jsx
    var a = {
    	name: 'shawn',
    	age: 11,
    };

    const {name, age} = a;

    // 아래와 같다
    const name = a.name;
    const age = a.age;

    function getName({name}) {
    	return name;
    }

    getName(a);
    ```

    - else if: 표준 스타일 가이드 위반사례

    ```jsx
    if (a) {
    ...
    } else if(b) {
    ...
    } else {
    ...
    }

    // 파싱하면
    if(a) {
    ...
    } else {
    	if(b) {
    		...
    	} else {
    		...
    	}
    }
    ```

## 5.2. 연산자 우선순위

1. `&&` > `||`
2. `&&` > `=`
3. `=` > `++`

### 5.2.1. 단락 평가

- a && b 에서 a 가 falsy이면 b는 평가하지 않음
- a || b 에서 a 가 truthy이면 b는 평가하지 않음
- `a && a.b` 에서 a 는 가드 → a ≠ undefined, null이라는 의미, reference error를 피하기 위해

### 5.2.2. 끈끈한 우정

- 삼항연산자는? → `&&` > `||` > `?:`

### 5.2.3. 결합성

- 처리 방향은 연산자에 따라 다르다
- `a ? b : c ? d : e` → 각 항목에 따라 상이하게 동작한다.

### 5.2.4. 분명히 하자.

- 이런 우선순위를 모두 꿰고 코딩해야 할까?
- 괄호 `( )`로 감싸야 할까?
- 단순하게 코딩하자.
- 필요할땐 괄호로 감싸자. → 애매한 케이스를 만들지 않는게 최선!

## 5.3. 세미콜론 자동 삽입

- 자바스크립트는 세미콜론으로 끝나지 않아도 동작한다. (optional)
- 하지만 세미콜론이 없을 때 오류가 발생할 수도 있다.
- ASI, Automatic Semicolon Insertion

### 5.3.1. 에러 정정

```jsx
function foo(a) {
	return
a * 2
;
}

foo(2) // undefined
```

## 5.4. 에러

- 컴파일시점에 에러가 발생하도록 문법정으로 정의되어 있음
- 엄격모드 (`"use strict";`)를 사용하면 조기에 에러를 발견할 수 있다.

### 5.4.1. 너무 이른 변수 사용

- 변수 선언보다 참조가 빠를 때 (TDZ) → `var`는 가능
- `typeof`는 TDZ의 영향을 받지 않음

## 5.5. 함수 인자

```jsx
function foo(a = 1, b = a + b + 5) {
...
}
// 아직 TDZ에 있는 b를 참조하려고 하기때문에 에러 발생, a는 문제 없음
```

- 디폴트 인자는 `arguments`와 다르다 → arguments는 실제 대입된 인자만을 바라본다.

## 5.6. try ... catch

- finally 블록은 반드시 실행되는 코드
- finally의 리턴은 그 전의 리턴값을 덮어쓴다.

## 5.7. switch

- case 매치 과정은 `===`
- 강제변환 등을 사용하려면 case문에서 `==`를 사용해야함
- switch문은 break가 없으면 계속 밑으로 실행한다

## 5.8. 정리하기

- 애매한 경우를 만들지 말자😂
- ES6+ 문법을 사용하자
- labeling, continue 등을 사용할 필요가 있을까?