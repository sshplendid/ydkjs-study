# 스코프란 무엇인가

특정 장소에 변수를 저장하고 나중에 그 변수를 찾는 데 잘 정의된 규칙을 스코프라 한다.

## 컴파일러 이론

자바스크립트 엔진은 전통적인 컴파일러 언어에서 컴파일러가 하는 일의 상당부분 동일하게 하는 컴퍼일 언어이다. 

컴파일되는 토크나이징/렉싱, 파싱, 코드 생성 3단계를 컴파일레이션이라고 한다.

### 토크나이징/렉싱

문자열을 토큰으로 만드는 과정이다. `var a = 2;`는 

+ `var`
+ `a` 
+ `=` 
+ `2`
+ `;`


이렇게 나눌 수 있다. 토크나이징과 렉싱은 미묘한 차이가 있는데 `a`가 별개의 토큰인지 다른 토큰의 일부인지를 파악하면 렉싱이다. 

### 파싱

파싱은 토큰 배열을 트리형태로 바꾸는 과정이다. 이렇게 만들어진 트리를 추상구문트리(AST abstract syntax tree)라 부른다.

### 코드생성
AST를 컴퓨터에서 실행 코드로 바꾸는 과정이다.


## 스코프 이해하기

+ 엔진 :컴파일레이션의 시작부터 끝까지 전 과정과 자바스크립트 프로그램 실행을 책임진다.
+ 컴파일러 : 파싱과 코드생성의 모든 과정을 처리한다.
+ 스코프 : 선언된 모든 확인자(변수) 검색 목록을 작성하고 유지한다. 또한, 엄격한 규칙을 강제하여 현재 실행코드에서 확인자의 적용방식을 정한다.

`var a = 2;`를 처리할 때 컴파일러는 변수 a가 특정 스코프 안에 있는지 확인하고 이미 있다면 선언을 무시하고 지나간다. 스코프 안에 없다면 컴파일러는 새로운 변수 a를 스코프 내에 선언하라고 요청한다.

그 후 컴파일러는 `a = 2;` 대입문을 처리하기 위해 스코프에 a 변수가 현재 스코프 내에서 접근할 수 있는지 확인하고 있다면 사용하고, 아니면 다른 곳을 탐색한다.

결국 변수를 찾으면 변수에 값을 넣고 못찾았다면 에러를 발생시킨다.

엔진은 변수를 검색할 때 좌측(LHS)이나 우측(RHS)에서 검색을 할 수 있는다. 여기서 방향은 대입연산방향을 말한다. 


```js
function foo(a) {
	console.log( a ); // 2
}

foo( 2 );
```

위 코드를 보면 foo()를 호출하는데 RHS를 사용해 값을 찾아오라 명령한다. 그리고 a에 대한 대입연산을 위해서는 LHS 검색이 수행된다.

### 퀴즈

1. 모든 LHS 검색
2. 모든 RHS 검색


```js
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );
```

### 퀴즈답안

1. 모든 LHS 검색

	**`c = ..`, `a = 2` (implicit param assignment) and `b = ..`**

2. 모든 RHS 검색

    **`foo(2..`, `= a;`, `a + ..` and `.. + b`**


## 중첩 스코프

하나의 블록이나 함수는 다른 블록이나 함수 안에 중첩될 수 있으므로 스코프도 다른 스코프 안에 중첩될 수 있다. 엔진은 검색 대상 변수를 현재 스코프에서 찾지 못하면 바깥의 스코프로 넘어가는 식으로 변수를 찾는다. 글로벌 스코프라고 부르는 가장 바깥 스코프에 도달할 때 까지 계속한다.


```js
function foo(a) {
	console.log( a + b );
}

var b = 2;

foo( 2 ); // 4
```

## 오류


```js
function foo(a) {
	console.log( a + b );
	b = a;
}

foo( 2 );
```

여기서 b는 선언되지 않은 변수이다. LHS 검색의 경우 엄격모드가 아니라면 글로벌 스코프 엔진이 검색하는 이름을 가진 새로운 변수를 생성해서 엔진에게 넘겨준다. ES5부터는 RHS와 같이 ReferenceError를 발생시킨다. 
